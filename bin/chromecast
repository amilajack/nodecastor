#!/usr/bin/env node
'use strict';

process.env['AVAHI_COMPAT_NOWARN'] = 1;

var util = require('util'),
    _ = require('lodash'),
    nodecastor = require('..'),
    pjson = require('../package.json'),
    ArgumentParser = require('argparse').ArgumentParser,
    parser = new ArgumentParser({
      version: pjson.version,
      description: 'Discover and interact with Google Chromecast devices.'
    });

parser
  .addArgument(['-d', '--debug'], {
    help: 'enable debugging',
    action: 'storeTrue'
  });

var subparsers = parser.addSubparsers({
  dest: 'command'
});

// discover command
var discover = subparsers.addParser('discover', {
  help: 'discover Chromecast devices on the network',
  description: 'List and show various information on Google Chromecast present on the network.'
});

function addHostAndPort(item) {
  item
    .addArgument(['host'], {
      help: 'Chromecast IP address',
      metavar: 'HOST'
    });
  item
    .addArgument(['-p', '--port'], {
      help: 'Chromecast port',
      metavar: 'PORT',
      defaultValue: 8009
    });
}

// ping command
var ping = subparsers.addParser('ping', {
  help: 'ping a Chromecast device',
  description: 'ping a Chromecast device'
});
addHostAndPort(ping);

// status command
var status = subparsers.addParser('status', {
  help: 'status of a Chromecast device',
  description: 'get status from a Chromecast device'
});
addHostAndPort(status);

// watch command
var watch = subparsers.addParser('watch', {
  help: 'watch a Chromecast device',
  description: 'watch and display any event hapenning on a Chromecast device'
});
addHostAndPort(watch);
watch.addArgument(['app'], {
  help: 'application ID',
  nargs: '?',
  metavar: 'APPID'
});

// Run an app
var run = subparsers.addParser('run', {
  help: 'run an application',
  description: 'run the provided application on a Chromecast device'
});
addHostAndPort(run);
run.addArgument(['app'], {
  help: 'application ID',
  metavar: 'APPID'
});

var args = parser.parseArgs();

function getChromecast() {
  var c = new nodecastor.Chromecast({ address: args.host,
                                      port: args.port,
                                      debug: args.debug });
  c
    .once('error', function(err) {
      console.warn('Error received', util.inspect(err));
      process.exit(1);
    })
    .once('disconnect', function() {
      console.warn('Got disconnected from device');
      process.exit(0);
    });
  return c;
}

switch (args.command) {
case 'discover':
  nodecastor.scan()
    .on('connected', function(device) {
      console.log('+ %s (%s:%d)', device.friendlyName, device.address, device.port);
    })
    .on('disconnected', function(device) {
      console.log('- %s (%s:%d)', device.friendlyName, device.address, device.port);
    })
    .start();
  break;

case 'ping':
  var c1 = getChromecast();
  c1
    .once('pong', function() {
      console.log('PONG received');
      c1.disconnect();
    });

  c1.ping();
  break;

case 'status':
  var c2 = getChromecast();
  c2
    .once('status', function(status) {
      console.log('Status received:', util.inspect(status));
      c2.disconnect();
    });
  c2.status();
  break;

case 'watch':
  var c3 = getChromecast();
  if (args.app) {
    c3.status();
    c3.once('status', function(status) {
      if (status.applications.length === 0) {
        console.log('No application running');
        c3.disconnect();
      } else {
        var app = _.find(status.applications, { appId: args.app });
        if (typeof app === 'undefined') {
          console.log('Application not found');
          c3.disconnect();
        } else {
          c3.stream.write({
            namespace: 'urn:x-cast:com.google.cast.tp.connection',
            destination: app.transportId,
            data: { type: 'CONNECT',
                    origin: {} }
          });
          c3.status();
        }
      }
    });
  }
  c3
    .on('message', function(message) {
      console.log('Message received:', util.inspect(message, { depth: null }));
    });
  break;

case 'run':
  var c4 = getChromecast();
  c4.run(args.app);
  c4.disconnect();
  break;

}
